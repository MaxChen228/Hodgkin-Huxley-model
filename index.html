<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hodgkin-Huxley Model Simulator</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;
      background: #121212;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    h1 { text-align: center; padding: 16px; font-size: 1.3rem; color: #fff; font-weight: 400; letter-spacing: 2px; background: #1a1a1a; }

    .main-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .top-section {
      display: flex;
      flex: 1;
      min-height: 0;
      padding: 12px;
      gap: 12px;
    }

    .chart-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .trace {
      height: 80px;
      flex-shrink: 0;
      background: #1e1e1e;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      position: relative;
    }
    .trace#trace-V {
      height: 120px;
    }
    .trace-label {
      position: absolute;
      top: 4px;
      left: 8px;
      font-size: 10px;
      font-weight: 500;
      z-index: 10;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }
    .trace canvas { display: block; width: 100%; height: 100%; }

    #trace-I .trace-label { color: #e91e63; }
    #trace-V .trace-label { color: #4caf50; }
    #trace-m .trace-label { color: #ff9800; }
    #trace-h .trace-label { color: #03a9f4; }
    #trace-n .trace-label { color: #9c27b0; }

    /* Right Control Panel */
    .control-panel {
      width: 140px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-shrink: 0;
    }

    .panel-section {
      background: #1e1e1e;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      padding: 10px;
    }
    .panel-section h3 {
      font-size: 9px;
      color: #666;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .manual-slider {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .manual-slider input[type="range"] {
      writing-mode: vertical-lr;
      direction: rtl;
      height: 120px;
      width: 20px;
      cursor: pointer;
      accent-color: #e91e63;
    }
    .manual-slider .value {
      font-size: 16px;
      color: #e91e63;
      margin-top: 6px;
      font-weight: 500;
    }

    .play-btn {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #333;
      border-radius: 3px;
      cursor: pointer;
      background: #252525;
      color: #aaa;
      transition: all 0.15s;
    }
    .play-btn:hover { background: #333; color: #fff; }
    .play-btn.playing { background: #4caf50; color: #fff; border-color: #4caf50; }

    .param-row {
      margin-bottom: 8px;
    }
    .param-row:last-child { margin-bottom: 0; }
    .param-row label {
      display: block;
      font-size: 9px;
      color: #666;
      margin-bottom: 3px;
      text-transform: uppercase;
    }
    .param-row input[type="range"] {
      width: 100%;
      accent-color: #4caf50;
    }
    .param-row .val {
      font-size: 11px;
      color: #4caf50;
      text-align: center;
      display: block;
      margin-top: 2px;
    }

    /* Bottom Template Section */
    .template-section {
      background: #1a1a1a;
      border-top: 1px solid #2a2a2a;
      padding: 12px;
    }
    .template-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .template-header h2 {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 500;
    }
    .template-off-btn {
      padding: 4px 12px;
      font-size: 10px;
      border: 1px solid #444;
      border-radius: 3px;
      background: #252525;
      color: #888;
      cursor: pointer;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .template-off-btn:hover { background: #333; color: #fff; }
    .template-off-btn.active { background: #e91e63; color: #fff; border-color: #e91e63; }

    .template-scroll {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 8px;
      scroll-behavior: smooth;
    }
    .template-scroll::-webkit-scrollbar {
      height: 6px;
    }
    .template-scroll::-webkit-scrollbar-track {
      background: #252525;
      border-radius: 3px;
    }
    .template-scroll::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 3px;
    }
    .template-scroll::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .template-card {
      flex-shrink: 0;
      width: 360px;
      background: #252525;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 14px;
      transition: all 0.15s;
    }
    .template-card:hover { border-color: #444; }
    .template-card.active {
      border-color: #e91e63;
      box-shadow: 0 0 0 1px #e91e63;
    }

    .template-card .preview-canvas {
      width: 100%;
      height: 55px;
      background: #1e1e1e;
      border-radius: 3px;
      margin-bottom: 10px;
    }
    .template-card .name {
      font-size: 13px;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      font-weight: 500;
    }
    .template-card.active .name { color: #e91e63; }

    .template-card .params {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .template-card .param {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .template-card .param label {
      font-size: 10px;
      color: #888;
      width: 65px;
      flex-shrink: 0;
      text-transform: uppercase;
    }
    .template-card .param input[type="range"] {
      flex: 1;
      height: 6px;
      accent-color: #e91e63;
    }
    .template-card .param .val {
      font-size: 11px;
      color: #e91e63;
      width: 32px;
      text-align: right;
    }

    .template-card .activate-btn {
      width: 100%;
      margin-top: 10px;
      padding: 8px;
      font-size: 11px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #333;
      color: #aaa;
      cursor: pointer;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.15s;
    }
    .template-card .activate-btn:hover { background: #444; color: #fff; }
    .template-card.active .activate-btn {
      background: #e91e63;
      color: #fff;
      border-color: #e91e63;
    }
  </style>
</head>
<body>
  <h1>Hodgkin-Huxley Model</h1>

  <div class="main-container">
    <div class="top-section">
      <div class="chart-area">
        <div class="trace" id="trace-I">
          <span class="trace-label">I(t) [μA/cm²]</span>
          <canvas id="canvas-I"></canvas>
        </div>
        <div class="trace" id="trace-V">
          <span class="trace-label">V(t) [mV]</span>
          <canvas id="canvas-V"></canvas>
        </div>
        <div class="trace" id="trace-m">
          <span class="trace-label">m (Na⁺ activation)</span>
          <canvas id="canvas-m"></canvas>
        </div>
        <div class="trace" id="trace-h">
          <span class="trace-label">h (Na⁺ inactivation)</span>
          <canvas id="canvas-h"></canvas>
        </div>
        <div class="trace" id="trace-n">
          <span class="trace-label">n (K⁺ activation)</span>
          <canvas id="canvas-n"></canvas>
        </div>
      </div>

      <div class="control-panel">
        <div class="panel-section">
          <h3>Manual I(t)</h3>
          <div class="manual-slider">
            <input type="range" id="i-slider" min="-20" max="80" step="0.5" value="0">
            <span class="value" id="i-value">0.0</span>
          </div>
        </div>

        <div class="panel-section">
          <h3>Playback</h3>
          <button class="play-btn playing" id="play-btn">⏸</button>
          <div class="param-row" style="margin-top:10px">
            <label>Time Window</label>
            <input type="range" id="window-slider" min="0" max="100" step="1" value="50">
            <span class="val" id="window-value">1414</span>
          </div>
          <div class="param-row">
            <label>Speed</label>
            <input type="range" id="speed-slider" min="1" max="20" step="1" value="2">
            <span class="val" id="speed-value">2</span>
          </div>
        </div>
      </div>
    </div>

    <div class="template-section">
      <div class="template-header">
        <h2>Waveform Templates</h2>
        <button class="template-off-btn" id="template-off">OFF</button>
      </div>
      <div class="template-scroll" id="template-scroll">
        <!-- Templates will be generated by JS -->
      </div>
    </div>
  </div>

<script>
// ========== Hodgkin-Huxley Model ==========
const HH = {
  C_m: 1.0,
  gNa: 120.0, gK: 36.0, gL: 0.3,
  ENa: 50.0, EK: -77.0, EL: -54.387,

  vtrap(x, y) {
    return Math.abs(x / y) < 1e-6 ? y * (1 - x / (2 * y)) : x / (1 - Math.exp(-x / y));
  },

  alpha_n(V) { return 0.01 * this.vtrap(V + 55.0, 10.0); },
  beta_n(V) { return 0.125 * Math.exp(-(V + 65.0) / 80.0); },
  alpha_m(V) { return 0.1 * this.vtrap(V + 40.0, 10.0); },
  beta_m(V) { return 4.0 * Math.exp(-(V + 65.0) / 18.0); },
  alpha_h(V) { return 0.07 * Math.exp(-(V + 65.0) / 20.0); },
  beta_h(V) { return 1.0 / (1.0 + Math.exp(-(V + 35.0) / 10.0)); },

  x_inf(alphaFn, betaFn, V) {
    const a = alphaFn.call(this, V), b = betaFn.call(this, V);
    return a / (a + b);
  },

  step(state, I, dt) {
    const { V, m, h, n } = state;
    const f = (V, m, h, n, I) => {
      const INa = this.gNa * Math.pow(m, 3) * h * (V - this.ENa);
      const IK = this.gK * Math.pow(n, 4) * (V - this.EK);
      const IL = this.gL * (V - this.EL);
      return {
        dV: (I - (INa + IK + IL)) / this.C_m,
        dm: this.alpha_m(V) * (1 - m) - this.beta_m(V) * m,
        dh: this.alpha_h(V) * (1 - h) - this.beta_h(V) * h,
        dn: this.alpha_n(V) * (1 - n) - this.beta_n(V) * n
      };
    };
    const k1 = f(V, m, h, n, I);
    const k2 = f(V + 0.5*dt*k1.dV, m + 0.5*dt*k1.dm, h + 0.5*dt*k1.dh, n + 0.5*dt*k1.dn, I);
    const k3 = f(V + 0.5*dt*k2.dV, m + 0.5*dt*k2.dm, h + 0.5*dt*k2.dh, n + 0.5*dt*k2.dn, I);
    const k4 = f(V + dt*k3.dV, m + dt*k3.dm, h + dt*k3.dh, n + dt*k3.dn, I);
    return {
      V: V + (dt/6) * (k1.dV + 2*k2.dV + 2*k3.dV + k4.dV),
      m: m + (dt/6) * (k1.dm + 2*k2.dm + 2*k3.dm + k4.dm),
      h: h + (dt/6) * (k1.dh + 2*k2.dh + 2*k3.dh + k4.dh),
      n: n + (dt/6) * (k1.dn + 2*k2.dn + 2*k3.dn + k4.dn)
    };
  },

  initState(V0 = -65.0) {
    return {
      V: V0,
      m: this.x_inf(this.alpha_m, this.beta_m, V0),
      h: this.x_inf(this.alpha_h, this.beta_h, V0),
      n: this.x_inf(this.alpha_n, this.beta_n, V0)
    };
  }
};

// ========== Template Definitions (Scalable) ==========
const TEMPLATE_DEFS = [
  {
    id: 'step',
    name: 'Step',
    params: [
      { id: 'amp', label: 'Amplitude', min: 1, max: 100, default: 15, step: 1 }
    ],
    fn: (t, p) => p.amp
  },
  {
    id: 'pulse',
    name: 'Pulse',
    params: [
      { id: 'amp', label: 'Amplitude', min: 1, max: 100, default: 20, step: 1 },
      { id: 'width', label: 'Width', min: 1, max: 50, default: 5, step: 1 },
      { id: 'period', label: 'Period', min: 10, max: 200, default: 50, step: 5 }
    ],
    fn: (t, p) => (t % p.period) < p.width ? p.amp : 0
  },
  {
    id: 'staircase',
    name: 'Staircase',
    params: [
      { id: 'amp', label: 'Max Amp', min: 5, max: 100, default: 30, step: 1 },
      { id: 'steps', label: 'Steps', min: 2, max: 6, default: 3, step: 1 },
      { id: 'duration', label: 'Step Dur', min: 10, max: 100, default: 30, step: 5 }
    ],
    fn: (t, p) => {
      const totalPeriod = p.steps * p.duration + p.duration;
      const phase = t % totalPeriod;
      const stepIdx = Math.floor(phase / p.duration);
      if (stepIdx >= p.steps) return 0;
      return p.amp * ((stepIdx + 1) / p.steps);
    }
  },
  {
    id: 'paired',
    name: 'Paired Pulse',
    params: [
      { id: 'amp', label: 'Amplitude', min: 5, max: 100, default: 25, step: 1 },
      { id: 'width', label: 'Width', min: 1, max: 20, default: 3, step: 1 },
      { id: 'interval', label: 'Interval', min: 5, max: 100, default: 20, step: 1 },
      { id: 'period', label: 'Period', min: 50, max: 300, default: 100, step: 10 }
    ],
    fn: (t, p) => {
      const phase = t % p.period;
      if (phase < p.width) return p.amp;
      if (phase >= p.interval && phase < p.interval + p.width) return p.amp;
      return 0;
    }
  },
  {
    id: 'burst',
    name: 'Burst',
    params: [
      { id: 'amp', label: 'Amplitude', min: 5, max: 100, default: 20, step: 1 },
      { id: 'count', label: 'Count', min: 2, max: 10, default: 5, step: 1 },
      { id: 'freq', label: 'Freq (Hz)', min: 20, max: 200, default: 100, step: 10 },
      { id: 'period', label: 'Period', min: 50, max: 300, default: 120, step: 10 }
    ],
    fn: (t, p) => {
      const phase = t % p.period;
      const pulseInterval = 1000 / p.freq;
      const burstDuration = p.count * pulseInterval;
      if (phase >= burstDuration) return 0;
      const subphase = phase % pulseInterval;
      return subphase < 2 ? p.amp : 0;
    }
  },
  {
    id: 'ramp',
    name: 'Ramp',
    params: [
      { id: 'amp', label: 'Max Amp', min: 5, max: 100, default: 25, step: 1 },
      { id: 'rise', label: 'Rise', min: 5, max: 100, default: 30, step: 5 },
      { id: 'hold', label: 'Hold', min: 0, max: 100, default: 20, step: 5 },
      { id: 'fall', label: 'Fall', min: 5, max: 100, default: 30, step: 5 }
    ],
    fn: (t, p) => {
      const period = p.rise + p.hold + p.fall + 20;
      const phase = t % period;
      if (phase < p.rise) return p.amp * (phase / p.rise);
      if (phase < p.rise + p.hold) return p.amp;
      if (phase < p.rise + p.hold + p.fall) return p.amp * (1 - (phase - p.rise - p.hold) / p.fall);
      return 0;
    }
  },
  {
    id: 'sine',
    name: 'Sine',
    params: [
      { id: 'amp', label: 'Amplitude', min: 1, max: 50, default: 15, step: 1 },
      { id: 'offset', label: 'DC Offset', min: 0, max: 50, default: 10, step: 1 },
      { id: 'freq', label: 'Freq (Hz)', min: 5, max: 100, default: 20, step: 5 }
    ],
    fn: (t, p) => p.offset + p.amp * Math.sin(2 * Math.PI * p.freq * t / 1000)
  },
  {
    id: 'modelock',
    name: 'Mode Lock',
    params: [
      { id: 'dc', label: 'DC', min: 0, max: 50, default: 10, step: 1 },
      { id: 'ac', label: 'AC Amp', min: 1, max: 30, default: 8, step: 1 },
      { id: 'freq', label: 'Freq (Hz)', min: 5, max: 100, default: 30, step: 5 }
    ],
    fn: (t, p) => p.dc + p.ac * Math.sin(2 * Math.PI * p.freq * t / 1000)
  },
  {
    id: 'noise',
    name: 'Noise',
    params: [
      { id: 'base', label: 'Baseline', min: 0, max: 30, default: 8, step: 1 },
      { id: 'amp', label: 'Amplitude', min: 1, max: 30, default: 10, step: 1 }
    ],
    fn: (t, p) => {
      // Pseudo-random noise using multiple sine waves
      const n = Math.sin(t * 0.73) + Math.sin(t * 1.37) + Math.sin(t * 2.19) + Math.sin(t * 0.31);
      return p.base + p.amp * (n / 4);
    }
  }
];

// ========== Template State Manager ==========
class TemplateManager {
  constructor(defs) {
    this.defs = defs;
    this.states = {};
    this.activeId = null;

    // Initialize states with defaults
    defs.forEach(def => {
      this.states[def.id] = {};
      def.params.forEach(param => {
        this.states[def.id][param.id] = param.default;
      });
    });
  }

  setParam(templateId, paramId, value) {
    if (this.states[templateId]) {
      this.states[templateId][paramId] = value;
    }
  }

  getParams(templateId) {
    return this.states[templateId] || {};
  }

  activate(templateId) {
    this.activeId = templateId;
  }

  deactivate() {
    this.activeId = null;
  }

  getValue(t) {
    if (!this.activeId) return 0;
    const def = this.defs.find(d => d.id === this.activeId);
    if (!def) return 0;
    return def.fn(t, this.states[this.activeId]);
  }

  isActive(templateId) {
    return this.activeId === templateId;
  }
}

// ========== Trace Renderer ==========
class TraceRenderer {
  constructor(canvasId, color, yMin, yMax) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.color = color;
    this.yMin = yMin;
    this.yMax = yMax;
    this.data = [];
    this.maxPoints = 800;
  }

  resize() {
    const rect = this.canvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.ctx.scale(dpr, dpr);
    this.width = rect.width;
    this.height = rect.height;
  }

  push(value) {
    this.data.push(value);
    if (this.data.length > this.maxPoints) this.data.shift();
  }

  draw() {
    const { ctx, width, height, data, yMin, yMax, color } = this;
    ctx.fillStyle = '#1e1e1e';
    ctx.fillRect(0, 0, width, height);

    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = (i / 4) * height;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }

    if (data.length < 2) return;

    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    const step = width / this.maxPoints;
    for (let i = 0; i < data.length; i++) {
      const x = i * step;
      const y = height - ((data[i] - yMin) / (yMax - yMin)) * height;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '9px monospace';
    ctx.fillText(yMax.toFixed(0), width - 28, 10);
    ctx.fillText(yMin.toFixed(0), width - 28, height - 3);
  }
}

// ========== UI Generation ==========
function createTemplateCard(def, manager, onActivate) {
  const card = document.createElement('div');
  card.className = 'template-card';
  card.dataset.templateId = def.id;

  // Preview canvas
  const canvas = document.createElement('canvas');
  canvas.className = 'preview-canvas';
  canvas.width = 332;
  canvas.height = 55;
  card.appendChild(canvas);

  // Name
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = def.name;
  card.appendChild(name);

  // Params container
  const paramsDiv = document.createElement('div');
  paramsDiv.className = 'params';

  def.params.forEach(param => {
    const paramDiv = document.createElement('div');
    paramDiv.className = 'param';

    const label = document.createElement('label');
    label.textContent = param.label;
    paramDiv.appendChild(label);

    const input = document.createElement('input');
    input.type = 'range';
    input.min = param.min;
    input.max = param.max;
    input.step = param.step;
    input.value = param.default;
    paramDiv.appendChild(input);

    const val = document.createElement('span');
    val.className = 'val';
    val.textContent = param.default;
    paramDiv.appendChild(val);

    input.addEventListener('input', () => {
      const v = parseFloat(input.value);
      manager.setParam(def.id, param.id, v);
      val.textContent = v;
      drawPreview(canvas, def, manager.getParams(def.id));
    });

    paramsDiv.appendChild(paramDiv);
  });

  card.appendChild(paramsDiv);

  // Activate button
  const btn = document.createElement('button');
  btn.className = 'activate-btn';
  btn.textContent = 'Activate';
  btn.addEventListener('click', () => onActivate(def.id));
  card.appendChild(btn);

  // Initial preview
  drawPreview(canvas, def, manager.getParams(def.id));

  return card;
}

function drawPreview(canvas, def, params) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;

  ctx.fillStyle = '#1e1e1e';
  ctx.fillRect(0, 0, w, h);

  // Determine y scale
  let maxVal = 1;
  const samples = [];
  for (let i = 0; i <= 100; i++) {
    const t = (i / 100) * 200;
    const v = def.fn(t, params);
    samples.push(v);
    if (Math.abs(v) > maxVal) maxVal = Math.abs(v);
  }
  maxVal *= 1.1;

  ctx.strokeStyle = '#e91e63';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let i = 0; i < samples.length; i++) {
    const x = (i / samples.length) * w;
    const y = h / 2 - (samples[i] / maxVal) * (h / 2 - 4);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Zero line
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h / 2);
  ctx.lineTo(w, h / 2);
  ctx.stroke();
}

// ========== Main Application ==========
let state = HH.initState();
let simTime = 0;
let isPlaying = true;
let manualI = 0;
const dt = 0.05;
let stepsPerFrame = 2;
let timeWindow = 1414;

const templateManager = new TemplateManager(TEMPLATE_DEFS);

const traces = {
  I: new TraceRenderer('canvas-I', '#e91e63', -30, 80),
  V: new TraceRenderer('canvas-V', '#4caf50', -90, 60),
  m: new TraceRenderer('canvas-m', '#ff9800', 0, 1),
  h: new TraceRenderer('canvas-h', '#03a9f4', 0, 1),
  n: new TraceRenderer('canvas-n', '#9c27b0', 0, 1)
};

// UI Elements
const iSlider = document.getElementById('i-slider');
const iValue = document.getElementById('i-value');
const playBtn = document.getElementById('play-btn');
const windowSlider = document.getElementById('window-slider');
const windowValue = document.getElementById('window-value');
const speedSlider = document.getElementById('speed-slider');
const speedValue = document.getElementById('speed-value');
const templateScroll = document.getElementById('template-scroll');
const templateOffBtn = document.getElementById('template-off');

// Event listeners
iSlider.addEventListener('input', () => {
  manualI = parseFloat(iSlider.value);
  iValue.textContent = manualI.toFixed(1);
});

playBtn.addEventListener('click', () => {
  isPlaying = !isPlaying;
  playBtn.textContent = isPlaying ? '⏸' : '▶';
  playBtn.classList.toggle('playing', isPlaying);
});

const WINDOW_MIN = 100, WINDOW_MAX = 20000;
function sliderToWindow(val) {
  return Math.round(WINDOW_MIN * Math.pow(WINDOW_MAX / WINDOW_MIN, val / 100));
}
windowSlider.addEventListener('input', () => {
  timeWindow = sliderToWindow(parseInt(windowSlider.value));
  windowValue.textContent = timeWindow;
  Object.values(traces).forEach(t => {
    t.maxPoints = timeWindow;
    while (t.data.length > timeWindow) t.data.shift();
  });
});
timeWindow = sliderToWindow(50);

speedSlider.addEventListener('input', () => {
  stepsPerFrame = parseInt(speedSlider.value);
  speedValue.textContent = stepsPerFrame;
});

// Create template cards
function updateActiveCard(activeId) {
  document.querySelectorAll('.template-card').forEach(card => {
    const isActive = card.dataset.templateId === activeId;
    card.classList.toggle('active', isActive);
  });
  templateOffBtn.classList.toggle('active', activeId !== null);
}

TEMPLATE_DEFS.forEach(def => {
  const card = createTemplateCard(def, templateManager, (id) => {
    templateManager.activate(id);
    updateActiveCard(id);
  });
  templateScroll.appendChild(card);
});

templateOffBtn.addEventListener('click', () => {
  templateManager.deactivate();
  updateActiveCard(null);
});

// Resize handling
function handleResize() {
  Object.values(traces).forEach(t => t.resize());
}
window.addEventListener('resize', handleResize);
setTimeout(handleResize, 50);

// Main loop
function loop() {
  requestAnimationFrame(loop);
  if (!isPlaying) return;

  for (let i = 0; i < stepsPerFrame; i++) {
    const templateI = templateManager.getValue(simTime);
    const I_total = manualI + templateI;
    state = HH.step(state, I_total, dt);
    simTime += dt;

    traces.I.push(I_total);
    traces.V.push(state.V);
    traces.m.push(state.m);
    traces.h.push(state.h);
    traces.n.push(state.n);
  }

  Object.values(traces).forEach(t => t.draw());
}

requestAnimationFrame(loop);
</script>
</body>
</html>
